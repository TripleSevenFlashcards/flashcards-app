<!doctype html>
<html>
<head>
  <!-- Head: metadata, viewport, inline styles -->
  <meta charset="utf-8" />
  <title>Flashcards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Styles: theme tokens, layout, buttons, responsiveness */
    :root{
      --bg1:#0c2146; --bg2:#0f356e; --panel:#ffffff; --accent:#2b8cff; --text:#0a0a0a; --muted:#5c646d;
      --ok:#1b8a3a; --bad:#b02a37; --next:#0d2c6d;
    }
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, #1a3f80 0%, transparent 60%), linear-gradient(135deg,var(--bg1),var(--bg2));
      color:#fff; display:flex; flex-direction:column; align-items:center;
    }

    /* Tight top bar */
    .topbar{width:100%; max-width:1100px; display:flex; align-items:center; gap:10px; padding:12px 16px;}
    .logo{height:36px}
    .brand{font-size:18px; font-weight:700; letter-spacing:.2px}

    /* Grid */
    .wrap{
      width:100%; max-width:1100px;
      display:grid; grid-template-columns: 280px 1fr; gap:14px;
      padding:0 16px 16px;
    }

     /* ===== Panel (shared white card container) ===== */
    .panel{
      background: var(--panel);           /* panel surface color (white) */
      color: var(--text);                 /* default text color inside panels */
      border-radius: 16px;                /* rounded corners */
      box-shadow: 0 10px 30px rgba(0,0,0,.25); /* soft elevation shadow */
      max-height: calc(100vh - 140px);    /* keep panel within viewport height */
      overflow: auto;                     /* scroll internally if content exceeds height */
      border: none;                       /* remove default border (no black outline) */
    }

    /* ===== Panel variants: left filter column / right study column ===== */
    .left{
      padding: 12px;                      /* inner spacing */
      display: flex;                      /* vertical layout for children */
      flex-direction: column;             /* stack children top-to-bottom */
    }
    .right{
      padding: 16px;                      /* slightly more padding for main area */
      min-height: 320px;                  /* ensure a reasonable minimum height */
      display: flex;                      /* layout container */
      flex-direction: column;             /* stack children */
    }

    /* ===== Typography utilities ===== */
    .muted{
      color: var(--muted);                /* subdued text color */
      font-size: 13px;                    /* small caption size */
    }
    .sectionTitle{
      font-weight: 700;                   /* bold section heading */
      margin: 6px 0 10px;                 /* spacing above/below the heading */
    }

    /* ===== Category list (left panel) ===== */
    .catlist{
      display: flex;                      /* vertical list container */
      flex-direction: column;             /* stack items */
      gap: 4px;                           /* space between items */
      max-height: 40vh;                   /* limit list height within viewport */
      overflow: auto;                     /* scroll if long */
      padding-right: 6px;                 /* room for scrollbar so text doesn’t collide */
    }
    .checkboxline{
      display: flex;                      /* align checkbox + label horizontally */
      gap: 6px;                           /* space between checkbox and label */
      align-items: center;                /* vertical centering */
    }
    .checkboxline span{
      font-size: 13px;                    /* label text size */
      line-height: 1.15;                  /* compact line height */
    }

    /* ===== Stats row (left panel) ===== */
    .statline{
      display: flex;                      /* lay out chips in a row */
      gap: 10px;                          /* space between chips */
      margin: 8px 0 12px;                 /* spacing around the row */
      flex-wrap: wrap;                    /* wrap to new line on narrow widths */
    }
    .chip{
      background: #eef3ff;                /* light bluish background */
      color: #0b2c5a;                     /* dark blue text for contrast */
      border: 1px solid #cfe0ff;          /* light outline */
      border-radius: 999px;               /* pill shape */
      padding: 6px 10px;                  /* inner spacing */
      font-size: 12px;                    /* compact size */
    }


    /* ===== Buttons: slightly smaller & narrower, ALL with black outline ===== */
    .btnrow{                           /* container for grouped buttons */
      display:flex;                    /* lay out buttons in a row */
      gap:10px;                        /* space between buttons */
      flex-wrap:wrap;                  /* wrap to next line on small screens */
    }
    button{
      padding:8px 12px;                /* compact button padding */
      border-radius:8px;               /* rounded corners */
      font-weight:600;                 /* semi-bold text */
      font-size:14px;                  /* button label size */
      cursor:pointer;                  /* pointer cursor on hover */
      text-transform:capitalize;       /* capitalize first letters */
      border:2px solid #000;           /* black outline around all buttons */
    }

    /* ===== Button color variants ===== */
    button.primary{                    /* "Show Answer" style */
      background:var(--accent);        /* primary color from theme */
      color:#fff;                      /* white text for contrast */
    }
    button.primary:hover{
      filter:brightness(0.95);         /* subtle darken on hover */
    }

    button.ok{                         /* "I Know" style */
      background:var(--ok);            /* success green */
      color:#fff;
    }
    button.ok:hover{
      filter:brightness(0.95);         /* slight darken on hover */
    }

    button.bad{                        /* "Don't Know" base style */
      background:#ffcccc;              /* light red background */
      color:#000;                      /* dark text on light red */
    }
    button.bad:hover{
      background:#b02a37;              /* strong red on hover */
      color:#fff;                      /* switch to white text for contrast */
    }

    button.next{                       /* Prev/Next navigation style */
      background:var(--next);          /* nav blue */
      color:#fff;
    }
    button.next:hover{
      filter:brightness(0.9);          /* a bit darker on hover */
    }

    button.restart{                    /* Clear/Shuffle button */
      background:#b02a37;              /* strong red */
      color:#fff;
    }
    button.restart:hover{
      filter:brightness(0.9);          /* darken on hover */
    }

    button.unhide{                     /* Unhide All button */
      background:#1b8a3a;              /* green */
      color:#fff;
    }
    button.unhide:hover{
      filter:brightness(0.9);          /* darken on hover */
    }

    /* ===== Hide Card (custom action) =====
       requested color: #435663 with black outline already inherited */
    button.hidecard{
      background:#435663;              /* slate blue/gray background */
      color:#fff;                      /* white text for readability */
    }

    /* ===== Card container styling ===== */
    #card{
      flex:1;                          /* fill available vertical space */
      border:1px solid #e3e8ef;        /* light border (restored) */
      border-radius:14px;              /* rounded corners */
      padding:16px;                    /* inner spacing */
      display:flex;                    /* vertical layout for contents */
      flex-direction:column;           /* stack children top-to-bottom */
      gap:12px;                        /* space between children */
    }

    /* ===== Question text ===== */
    .q{
      font-size:20px;                  /* question font size */
      font-weight:700;                 /* bold for emphasis */
    }



    /* ===== Image boxes with light outline ===== */
    /* Optional image containers; hidden until image loads */
    .imgbox{
      width:6in; height:auto; max-width:100%;                 /* target width; scale down on small screens */
      background:#f6f8fb; border:1px solid #d9e1ee;           /* light border + subtle background */
      border-radius:10px; display:none; overflow:hidden;       /* hidden by default; clip overflowing content */
      margin-top:8px;                                          /* space above image block */
    }
    .imgbox img{
      width:100%; height:auto;                                 /* responsive image sizing */
      object-fit:contain; display:block;                       /* keep aspect ratio; remove inline gap */
    }

    /* ===== Answer text box ===== */
    .a{
      display:none; color:#1d2630; background:#f6f8fb;         /* hidden until shown; dark text on light bg */
      border:1px dashed #d9e1ee;                               /* light dashed border */
      border-radius:10px; padding:14px; white-space:pre-wrap;   /* rounded, padded, preserve line breaks */
    }

    /* ===== Small text utility ===== */
    .small{font-size:12px}                                     /* compact text size */

    /* ===== Footer / link rows ===== */
    .footerline{
      margin-top:10px; display:flex; gap:10px;                 /* flex row with spacing */
      align-items:center; justify-content:space-between;       /* center vertically; spread ends */
    }
    .linkrow{
      display:flex; gap:10px; align-items:center;              /* horizontal group for links/icons */
      flex-wrap:wrap;                                          /* wrap on narrow screens */
    }
    .extlink{
      display:inline-flex; align-items:center; gap:6px;         /* icon + text alignment */
      background:#e8f1ff; color:#0b2c5a;                        /* light blue chip look */
      border:1px solid #cfe0ff;                                 /* light outline */
      border-radius:8px; padding:6px 10px;                      /* pill-ish padding */
      text-decoration:none; font-weight:600;                    /* remove underline; semi-bold */
    }
    .extlink:hover{background:#dceaff}                          /* slightly darker on hover */

    /* ===== Answer wrapper (text + optional image) ===== */
    .answrap{display:none; flex-direction:column; gap:10px;}    /* shown only when answer is visible */

    /* ===== Hide button look (yellow) ===== */
    .hidebtn{background:#ffd400; color:#000; border:2px solid #ffd400;} /* high-visibility button */
    .hidebtn:hover{filter:brightness(0.95);}                     /* slight darken on hover */

    /* ===== Bottom controls layout ===== */
    .controls-row{display:flex; align-items:center; gap:10px; width:100%;} /* nav + grading row */
    .grow{flex:1;}                                               /* spacer to push side buttons apart */



  </style>
</head>
<body>
  <!-- Body: top bar, left drawer, right flashcard panel -->

  <!-- Top bar: brand + hamburger (branding header; no controls here) -->
  <div class="topbar">
    <!-- App logo image -->
    <img class="logo" src="/static/logo.jpg" alt="logo">
    <!-- App name text -->
    <div class="brand">Triple Seven Aviation Flashcards</div>
  </div>

  <!-- Main grid wrapper (left filter panel + right study panel) -->
  <div class="wrap">

    <!-- LEFT PANEL: categories, session controls, stats -->
    <div class="panel left">
      <!-- Categories heading -->
      <div class="sectionTitle">Categories</div>
      <!-- Category checkboxes are injected here by buildCategoryUI() -->
      <div id="categories" class="catlist"></div>

      <!-- Session controls (shuffle / unhide) -->
      <div class="sectionTitle" style="margin-top:10px;">Session Controls</div>
      <div class="btnrow">
        <!-- Restart: clears progress + reshuffles fullDeck; see btnRestart.onclick -->
        <button id="restart" class="restart" title="Clear progress and reshuffle the deck.">Restart (Clear & Shuffle)</button>
        <!-- Unhide: clears hiddenIds and refilters; see btnUnhide.onclick -->
        <button id="unhide" class="unhide" title="Unhide all previously hidden cards.">Show Hidden Again</button>
      </div>

      <!-- Stats section (counts update in refilter()/render()) -->
      <div class="sectionTitle" style="margin-top:10px;">Stats</div>
      <div id="stats" class="statline">
        <!-- Total answered so far in current filter -->
        <span class="chip">Answered: <b id="s-seen">0</b></span>
        <!-- Correct answers -->
        <span class="chip">Correct: <b id="s-ok">0</b></span>
        <!-- Incorrect answers -->
        <span class="chip">Incorrect: <b id="s-wrong">0</b></span>
        <!-- Accuracy percentage -->
        <span class="chip">Accuracy: <b id="s-acc">0%</b></span>
      </div>
      <!-- Scope note for stats -->
      <div class="muted small">Stats only count cards in the categories currently checked.</div>
    </div>

    <!-- RIGHT PANEL: flashcard content + controls -->
    <div class="panel right">
      <!-- Status line (e.g., loading, errors) -->
      <div id="status" class="muted">Loading deck…</div>

      <!-- Card container (question, answer, controls, footer) -->
      <div id="card">

        <!-- QUESTION WRAPPER -->
        <div id="qwrap">
          <!-- Question text node -->
          <div class="q" id="qtext"></div>
          <!-- Optional question image; shown after successful load -->
          <div id="qimgbox" class="imgbox"><img id="qimg" alt=""></div>
          <!-- Optional external resource link; hidden unless URL present -->
          <div class="linkrow" id="linkrow" style="display:none">
            <a id="qurl" class="extlink" target="_blank" rel="noopener">Open Additional Resources</a>
          </div>
        </div>

        <!-- ANSWER WRAPPER (text + optional image); toggled by Show Answer -->
        <div class="answrap" id="answrap">
          <!-- Answer text node -->
          <div class="a" id="ans"></div>
          <!-- Optional answer image; shown after successful load -->
          <div id="aimgbox" class="imgbox"><img id="aimg" alt=""></div>
        </div>

        <!-- CONTROLS ROW: prev / grading buttons / next -->
        <div class="controls-row">
          <!-- Go to previous card (does not grade) -->
          <button id="prev" class="next" title="Go to the previous card.">Previous</button>

          <!-- Core actions: reveal/grade/hide -->
          <div class="btnrow">
            <!-- Toggle answer visibility for current card -->
            <button id="show" class="primary" title="Reveal or hide the answer for this card.">Show Answer</button>
            <!-- Mark current card correct; advance -->
            <button id="correct" class="ok" title="Mark this card correct and move on.">I Knew It</button>
            <!-- Mark current card incorrect; advance -->
            <button id="wrong" class="bad" title="Mark this card wrong and move on.">I Missed It</button>
            <!-- Hide current card from rotation (adds to hiddenIds) -->
            <button id="hideCardBtn" class="hidecard" title="Hide this card from rotation.">Hide Card</button>
          </div>

          <!-- Flexible spacer to push Next button to the right -->
          <div class="grow"></div>

          <!-- Go to next card (does not grade) -->
          <button id="next" class="next" title="Skip to the next card without marking.">Next</button>
        </div>

        <!-- FOOTER: category + position (e.g., '3 / 20') -->
        <div class="footerline small">
          <!-- Current card category label -->
          <div id="footcat" class="muted"></div>
          <!-- Current index/total -->
          <div id="pos" class="muted"></div>
        </div>

      </div> <!-- /#card -->
    </div>   <!-- /.panel.right -->
  </div>     <!-- /.wrap -->


  <script>
    // ===== Script: DOM references, app state, handlers, data loading =====

    // --- Status / headings / containers ---
    const statusEl = document.getElementById('status');     // status text (loading/errors)
    const qText    = document.getElementById('qtext');      // question text node

    // --- Question image elements ---
    const qImg     = document.getElementById('qimg');       // <img> for question
    const qImgBox  = document.getElementById('qimgbox');    // wrapper shown when image loads

    // --- External link for extra resources (optional) ---
    const linkRow  = document.getElementById('linkrow');    // row that holds the link; hidden if no URL
    const qUrl     = document.getElementById('qurl');       // anchor element for external resource

    // --- Answer elements ---
    const ansWrap  = document.getElementById('answrap');    // container for answer content; toggled by Show
    const ansEl    = document.getElementById('ans');        // answer text node
    const aImg     = document.getElementById('aimg');       // <img> for answer
    const aImgBox  = document.getElementById('aimgbox');    // wrapper shown when answer image loads

    // --- Footer / progress indicators ---
    const posEl    = document.getElementById('pos');        // "current / total" position text
    const footCat  = document.getElementById('footcat');    // current card category label

    // --- Categories list container (left panel) ---
    const catsEl   = document.getElementById('categories'); // checkbox list rendered by buildCategoryUI()

    // --- Stats chips (left panel) ---
    const sSeen    = document.getElementById('s-seen');     // total answered in current filter
    const sOk      = document.getElementById('s-ok');       // number correct
    const sWrong   = document.getElementById('s-wrong');    // number incorrect
    const sAcc     = document.getElementById('s-acc');      // accuracy percentage text

    // --- Core control buttons ---
    const showBtn  = document.getElementById('show');       // reveal/hide answer
    const prevBtn  = document.getElementById('prev');       // previous card (no grade)
    const nextBtn  = document.getElementById('next');       // next card (no grade)
    const hideBtn  = document.getElementById('hideCardBtn'); // hide current card from rotation


    // ===== App state =====
    // fullDeck: all cards loaded from backend
    // categories: list of unique category names (strings)
    // selectedCats: which categories are currently ON (checkboxes)
    // hiddenIds: card IDs the user chose to hide (persisted in localStorage)
    let fullDeck = [],
        categories = [],
        selectedCats = new Set(),
        hiddenIds = new Set(JSON.parse(localStorage.getItem('hiddenIds') || '[]'));

    // progress: per-card correctness tracking (persisted)
    //   - ok:   map {id: true} for cards answered correctly (latest outcome)
    //   - seen: map {id: count} for how many times card was shown
    let progress = JSON.parse(localStorage.getItem('progress') || '{"ok":{},"seen":{}}');

    // idx: index into the filtered array for the current card
    // filtered: current working deck (category + hidden applied)
    let idx = 0, filtered = [];

    // ===== Data normalization =====
    // normCard: ensure each card has the fields our UI expects.
    // Fallbacks are provided to tolerate slightly different payload shapes.
    function normCard(c, i){
      return {
        id: c.id ?? i,                              // stable ID, fallback to array index
        q:  c.question ?? c.q ?? '',               // question text
        a:  c.answer   ?? c.a ?? '',               // answer text
        image:        c.image ?? '',               // optional question image path
        answer_image: c.answer_image ?? '',        // optional answer image path
        url: (c.url ?? '').toString().trim(),      // optional external resource URL
        category: (c.category ?? c.subject ?? '').toString() // category/subject label
      };
    }

    // uniqCats: derive and sort unique category names from a deck
    function uniqCats(deck){
      return Array.from(new Set(deck.map(c => c.category).filter(Boolean))).sort();
    }

    // shuffle: in-place Fisher–Yates shuffle, return same array for chaining
    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ===== Persistence helpers =====
    // Save current hidden set to localStorage
    function saveHidden(){
      localStorage.setItem('hiddenIds', JSON.stringify([...hiddenIds]));
    }
    // Save progress maps (ok/seen) to localStorage
    function saveProgress(){
      localStorage.setItem('progress', JSON.stringify(progress));
    }

    // ===== UI: Categories =====
    // buildCategoryUI: render category checkboxes and wire a single change handler
    function buildCategoryUI(){
      catsEl.innerHTML = '';                        // clear previous list (if any)

      // Build one checkbox row per category
      categories.forEach(cat => {
        const row = document.createElement('label');
        row.className = 'checkboxline';
        row.innerHTML = `
          <input type="checkbox" data-cat="${cat}" checked>
          <span>${cat}</span>`;
        catsEl.appendChild(row);
      });

      // Initialize selection to all categories ON
      selectedCats = new Set(categories);

      // Delegate change handling to the container (event bubbling)
      catsEl.onchange = e => {
        if (e.target.matches('input[data-cat]')){
          const cat = e.target.getAttribute('data-cat');

          // Toggle membership in selectedCats
          if (e.target.checked) selectedCats.add(cat);
          else selectedCats.delete(cat);

          // Rebuild filtered deck and re-render current card view
          refilter();
          render();
        }
      };
    }


    <!-- ===== Logic: filtering, stats, rendering, handlers, boot ===== -->
    <script>
      // refilter: rebuild deck from chosen categories and not-hidden; update stats
      function refilter(){
        // Build filtered by: (a) category selected or missing, and (b) not hidden by ID
        filtered = fullDeck.filter(c => (!c.category || selectedCats.has(c.category)) && !hiddenIds.has(String(c.id)));
        // Keep index in range after filtering
        if (idx >= filtered.length) idx = 0;
        updateStats(); // refresh chips in the left panel
      }

      // Recompute session stats for the CURRENT filtered set and paint UI
      function updateStats(){
        let seen = 0, ok = 0;
        // Tally seen/ok only for cards that are in the filtered deck
        filtered.forEach(c => {
          const id = String(c.id);
          if (progress.seen[id]) seen++;
          if (progress.ok[id])   ok++;
        });
        // Wrong = seen - ok (never negative)
        const wrong = Math.max(seen - ok, 0);
        // Update stat chips
        sSeen.textContent  = seen;
        sOk.textContent    = ok;
        sWrong.textContent = wrong;
        sAcc.textContent   = seen ? Math.round((ok/seen)*100)+'%' : '0%';
      }

      // Quick guard for external links: only allow http/https
      function isHttpUrl(u){ return /^https?:\/\//i.test(u); }

      // Reset all "answer is visible" UI back to the hidden/initial state
      function resetAnswerHiddenUI(){
        ansEl.style.display = 'none';        // hide text answer
        aImgBox.style.display = 'none';      // hide image wrapper
        aImg.removeAttribute('src');         // clear answer image
        aImg.removeAttribute('alt');
        ansWrap.style.display = 'none';      // hide whole answer region
        showBtn.textContent = 'Show Answer'; // restore button label
        showBtn.classList.add('primary');    // set to primary style
        showBtn.classList.remove('hidebtn'); // remove "hide" style
      }

      // render: show current card, images, answer visibility, progress
      function render(){
        // Empty state: nothing matches filters
        if (!filtered.length){
          qText.textContent   = "No cards match filters.";
          qImgBox.style.display = 'none';
          linkRow.style.display = 'none';
          resetAnswerHiddenUI();
          posEl.textContent   = ''; 
          footCat.textContent = '';
          // hide nav buttons to avoid dead actions
          prevBtn.style.display = 'none';
          nextBtn.style.display = 'none';
          return;
        }

        // Bind current card
        const c = filtered[idx];
        qText.textContent = c.q || '';

        // Question image handling
        if (c.image){
          qImg.src = c.image;
          qImg.alt = c.q ? `Front image — ${c.q}` : 'Front image';
          qImgBox.style.display = 'block';     // show image wrapper after binding
        } else {
          qImgBox.style.display = 'none';
          qImg.removeAttribute('src'); 
          qImg.removeAttribute('alt');
        }

        // Optional external resource link (only for valid http(s) URLs)
        if (c.url && isHttpUrl(c.url)){
          qUrl.href = c.url;
          qUrl.textContent = 'Open Related Resource';
          linkRow.style.display = '';
        } else {
          linkRow.style.display = 'none';
          qUrl.removeAttribute('href');
        }

        // Answer area starts hidden on each render
        resetAnswerHiddenUI();

        // Footer labels: category + position
        footCat.textContent = c.category ? `Category: ${c.category}` : 'Category: —';
        posEl.textContent   = `Card ${idx+1} of ${filtered.length}`;

        // Show/hide nav buttons at edges
        prevBtn.style.display = (idx === 0) ? 'none' : '';
        nextBtn.style.display = (idx === filtered.length - 1) ? 'none' : '';
      }

      // Show/Hide Answer toggle
      showBtn.onclick = () => {
        if (!filtered.length) return;

        // Determine if anything in the answer area is visible right now
        const currentlyVisible =
          ansWrap.style.display !== 'none' &&
          (ansEl.style.display === 'block' || aImgBox.style.display !== 'none');

        if (currentlyVisible) {
          // Hide everything if currently visible
          resetAnswerHiddenUI();
        } else {
          // Otherwise show any available answer content
          const c = filtered[idx];
          let anything = false;

          // Text answer
          if (c.a){
            ansEl.style.display = 'block';
            ansWrap.style.display = 'flex';
            anything = true;
          }

          // Image answer
          if (c.answer_image){
            aImg.src = c.answer_image;
            aImg.alt = c.q ? `Back image — ${c.q}` : 'Back image';
            aImgBox.style.display = 'block';
            ansWrap.style.display = 'flex';
            anything = true;
          }

          // If neither text nor image is present, show a placeholder
          if (!anything){
            ansWrap.style.display = 'flex';
            ansEl.style.display   = 'block';
            ansEl.textContent     = '(No answer provided)';
          }

          // Flip button into "Hide" state + styling
          showBtn.textContent = 'Hide Answer';
          showBtn.classList.add('hidebtn');
          showBtn.classList.remove('primary');
        }
      };

      // Navigation & grading
      nextBtn.onclick = () => {
        if (filtered.length){
          idx = Math.min(idx + 1, filtered.length - 1); // clamp to last index
          render();
        }
      };
      prevBtn.onclick = () => {
        if (filtered.length){
          idx = Math.max(idx - 1, 0); // clamp to first index
          render();
        }
      };
      // Mark correct: update progress, save, refresh stats, advance
      document.getElementById('correct').onclick = () => {
        if (filtered.length){
          const id = String(filtered[idx].id);
          progress.ok[id]   = true;    // last outcome = correct
          progress.seen[id] = true;    // seen at least once
          saveProgress();              // persist to localStorage
          updateStats();               // refresh left chips
          nextBtn.click();             // move forward
        }
      };
      // Mark wrong: clear ok flag, mark seen, save, refresh, advance
      document.getElementById('wrong').onclick = () => {
        if (filtered.length){
          const id = String(filtered[idx].id);
          delete progress.ok[id];      // not correct
          progress.seen[id] = true;    // seen at least once
          saveProgress();
          updateStats();
          nextBtn.click();
        }
      };

      // Hide Card button: add current ID to hidden set and rebuild deck
      hideBtn.onclick = () => {
        if (!filtered.length) return;
        const id = String(filtered[idx].id);
        hiddenIds.add(id);       // hide for this session (persisted)
        saveHidden();
        statusEl.textContent = 'Card hidden.';
        refilter();              // rebuild filtered after hiding

        // Keep index valid and re-render (both branches call render)
        if (filtered.length){
          idx = Math.min(idx, filtered.length - 1);
          render();
        } else {
          render();
        }
      };

      // Session controls
      document.getElementById('restart').onclick = () => {
        // Reset progress + hidden; shuffle and start over at idx 0
        progress = { ok:{}, seen:{} }; 
        saveProgress();
        hiddenIds = new Set(); 
        saveHidden();
        shuffle(fullDeck); 
        refilter(); 
        idx = 0; 
        render();
        statusEl.textContent = 'Session restarted.';
      };
      document.getElementById('unhide').onclick = () => {
        // Reveal all hidden cards and refresh view
        hiddenIds = new Set(); 
        saveHidden(); 
        refilter(); 
        render();
        statusEl.textContent = 'All hidden cards are now visible.';
      };

      // Boot: fetch deck, normalize, build UI, filter, render
      (async function boot(){
        statusEl.textContent = 'Loading deck…';
        try{
          // Fetch cards JSON (avoid cache so changes appear during study)
          const res  = await fetch('/api/cards', { cache: 'no-store' });
          const data = await res.json();

          // Normalize regardless of payload shape: [] or {cards:[...]}
          fullDeck = (Array.isArray(data) ? data : (data.cards || [])).map(normCard);
          if (!fullDeck.length) throw new Error('No cards in cards.json');

          // Build categories UI, apply initial filter, render first card
          categories = uniqCats(fullDeck); 
          buildCategoryUI();
          refilter(); 
          idx = 0; 
          render();

          statusEl.textContent = `Loaded ${fullDeck.length} cards.`;
        } catch(e){
          // Friendly error paint
          statusEl.textContent = 'Failed to load cards: ' + e.message;
          qText.textContent = 'Loading failed.';
        }
      })();
    </script>
  </body>
</html>
